package com.example.demo.designpattern.proxypattern;

/**
 * 代理模式中的角色有：

 抽象对象角色(AbstractObject)：声明了目标对象和代理对象的共同接口，这样依赖在任何可以使用目标对象的地方都可以使用代理对象。
 目标对象角色(RealObject)：定义了代理对象所代表的目标对象。
 代理对象角色(ProxyObject)：代理对象内部含有目标对象的引用，从而可以在任何时候操作目标对象；代理对象提供一个与目标对象相同的接口，以便可以在任何时候替代目标对象。代理对象通常在客户端调用传递给目标对象之前或者之后，执行某个操作，而不是单纯的将调用传递给目标对象。

 静态代理方式总结
 可以做到在不修改目标对象的前提下，拓展目标对象的功能。
 缺点是：因为代理对象需要同目标对象实现同样的接口，所以会有很多的代理类，造成类过多；并且，一旦接口中增加方法，目标对象同代理对象都需要进行维护。
 解决这个缺点的方式就是使用动态代理。

 动态代理
 动态代理主要有如下特点：

 代理对象不需要实现目标对象的接口。
 代理对象的生成，使用的是Java的API，动态的在内存中构件代理对象(这需要我们指定创建代理对象/目标对象的接口的类型)。
 动态代理也叫做JDK代理、接口代理。

 Cglib代理
 上面的静态代理和动态代理模式都需要目标对象是一个实现了接口的目标对象，但是有的时候，目标对象可能只是一个单独的对象，并没有实现任何的接口，这个时候，我们就可以使用目标对象子类的方式实现代理，这种代理方式就是：Cglib代理

 定义
 Cglib代理，也叫做子类代理，它是在内存中构件一个子类对象，从而实现对目标对象的功能拓展。

 JDK的动态代理有个限制，就是使用动态代理的目标对象必须实现至少一个接口，由此，没有实现接口但是想要使用代理的目标对象，就可以使用Cglib代理。
 Cglib是强大的高性能的代码生成包，它可以在运行期间拓展Java类与实现Java接口。它广泛的被许多AOP的框架使用，例如Spring AOP和synaop，为他们提供方法的interception(拦截)。
 Cglib包的底层是通过使用一个小而快的字节码处理框架ASM来转换字节码并生成新的类，不鼓励直接只使用ASM，因为它要求你必须对JVM内部结构，包括class文件的格式和指令集都很熟悉。

 引入包后，就可以在内存中动态构建子类。
 代理的对象不能为final的，否则会报错。
 目标对象的方法如果为final/static修饰的，那么就不会被拦截，即不会执行目标对象额外的方法。
 */
public class Notice {
}
